{"version":3,"file":"micromark-extension-math-CUC_GoCG.js","sources":["../../node_modules/micromark-extension-math/lib/math-flow.js","../../node_modules/micromark-extension-math/lib/math-text.js","../../node_modules/micromark-extension-math/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, 'whitespace')(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n    if (code === 36) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n    if (self.interrupt) {\n      return ok(code)\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {\n        tokenize: tokenizeClosingFence,\n        partial: true\n      },\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            'linePrefix',\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can use two or more dollars for text math.\n\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nexport function mathText(options) {\n  const options_ = options || {}\n  let single = options_.singleDollarTextMath\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n    return start\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return sequenceOpen(code)\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return sequenceOpen\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code)\n      }\n      effects.exit('mathTextSequence')\n      return between(code)\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code)\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return sequenceClose(code)\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return between\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return between\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return between(code)\n      }\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return sequenceClose\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n      enter = undefined\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('./math-text.js').Options} Options\n */\n\nimport {mathFlow} from './math-flow.js'\nimport {mathText} from './math-text.js'\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  }\n}\n"],"names":["mathFlow","tokenizeMathFenced","nonLazyContinuation","tokenizeNonLazyContinuation","effects","ok","nok","self","tail","initialSize","sizeOpen","start","code","sequenceOpen","factorySpace","metaBefore","markdownLineEnding","metaAfter","meta","beforeNonLazyContinuation","after","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","size","beforeSequenceClose","sequenceClose","afterSequenceClose","lineStart","mathText","options","single","tokenizeMathText","resolveMathText","previous","token","between","data","events","tailExitIndex","headEnterIndex","index","enter","math"],"mappings":"iJAUO,MAAMA,EAAW,CACtB,SAAUC,EACV,SAAU,EACZ,EAGMC,EAAsB,CAC1B,SAAUC,EACV,QAAS,EACX,EAMA,SAASF,EAAmBG,EAASC,EAAIC,EAAK,CAC5C,MAAMC,EAAO,KACPC,EAAOD,EAAK,OAAOA,EAAK,OAAO,OAAS,CAAC,EACzCE,EACJD,GAAQA,EAAK,CAAC,EAAE,OAAS,aACrBA,EAAK,CAAC,EAAE,eAAeA,EAAK,CAAC,EAAG,EAAI,EAAE,OACtC,EACN,IAAIE,EAAW,EACf,OAAOC,EAcP,SAASA,EAAMC,EAAM,CACnB,OAAAR,EAAQ,MAAM,UAAU,EACxBA,EAAQ,MAAM,eAAe,EAC7BA,EAAQ,MAAM,uBAAuB,EAC9BS,EAAaD,CAAI,CACzB,CAcD,SAASC,EAAaD,EAAM,CAC1B,OAAIA,IAAS,IACXR,EAAQ,QAAQQ,CAAI,EACpBF,IACOG,GAELH,EAAW,EACNJ,EAAIM,CAAI,GAEjBR,EAAQ,KAAK,uBAAuB,EAC7BU,EAAaV,EAASW,EAAY,YAAY,EAAEH,CAAI,EAC5D,CAeD,SAASG,EAAWH,EAAM,CACxB,OAAIA,IAAS,MAAQI,EAAmBJ,CAAI,EACnCK,EAAUL,CAAI,GAEvBR,EAAQ,MAAM,mBAAmB,EACjCA,EAAQ,MAAM,cAAe,CAC3B,YAAa,QACnB,CAAK,EACMc,EAAKN,CAAI,EACjB,CAcD,SAASM,EAAKN,EAAM,CAClB,OAAIA,IAAS,MAAQI,EAAmBJ,CAAI,GAC1CR,EAAQ,KAAK,aAAa,EAC1BA,EAAQ,KAAK,mBAAmB,EACzBa,EAAUL,CAAI,GAEnBA,IAAS,GACJN,EAAIM,CAAI,GAEjBR,EAAQ,QAAQQ,CAAI,EACbM,EACR,CAcD,SAASD,EAAUL,EAAM,CAGvB,OADAR,EAAQ,KAAK,eAAe,EACxBG,EAAK,UACAF,EAAGO,CAAI,EAETR,EAAQ,QACbF,EACAiB,EACAC,CACD,EAACR,CAAI,CACP,CAeD,SAASO,EAA0BP,EAAM,CACvC,OAAOR,EAAQ,QACb,CACE,SAAUiB,EACV,QAAS,EACV,EACDD,EACAE,CACD,EAACV,CAAI,CACP,CAcD,SAASU,EAAaV,EAAM,CAC1B,OACEH,EACIK,EACEV,EACAmB,EACA,aACAd,EAAc,CACf,EACDc,GACJX,CAAI,CACP,CAcD,SAASW,EAAmBX,EAAM,CAChC,OAAIA,IAAS,KACJQ,EAAMR,CAAI,EAEfI,EAAmBJ,CAAI,EAClBR,EAAQ,QACbF,EACAiB,EACAC,CACD,EAACR,CAAI,GAERR,EAAQ,MAAM,eAAe,EACtBoB,EAAaZ,CAAI,EACzB,CAcD,SAASY,EAAaZ,EAAM,CAC1B,OAAIA,IAAS,MAAQI,EAAmBJ,CAAI,GAC1CR,EAAQ,KAAK,eAAe,EACrBmB,EAAmBX,CAAI,IAEhCR,EAAQ,QAAQQ,CAAI,EACbY,EACR,CAcD,SAASJ,EAAMR,EAAM,CACnB,OAAAR,EAAQ,KAAK,UAAU,EAChBC,EAAGO,CAAI,CACf,CAGD,SAASS,EAAqBjB,EAASC,EAAIC,EAAK,CAC9C,IAAImB,EAAO,EAWX,OAAOX,EACLV,EACAsB,EACA,aACAnB,EAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,EACvD,OACA,CACL,EAcD,SAASmB,EAAoBd,EAAM,CACjC,OAAAR,EAAQ,MAAM,eAAe,EAC7BA,EAAQ,MAAM,uBAAuB,EAC9BuB,EAAcf,CAAI,CAC1B,CAcD,SAASe,EAAcf,EAAM,CAC3B,OAAIA,IAAS,IACXa,IACArB,EAAQ,QAAQQ,CAAI,EACbe,GAELF,EAAOf,EACFJ,EAAIM,CAAI,GAEjBR,EAAQ,KAAK,uBAAuB,EAC7BU,EAAaV,EAASwB,EAAoB,YAAY,EAAEhB,CAAI,EACpE,CAcD,SAASgB,EAAmBhB,EAAM,CAChC,OAAIA,IAAS,MAAQI,EAAmBJ,CAAI,GAC1CR,EAAQ,KAAK,eAAe,EACrBC,EAAGO,CAAI,GAETN,EAAIM,CAAI,CAChB,CACF,CACH,CAMA,SAAST,EAA4BC,EAASC,EAAIC,EAAK,CACrD,MAAMC,EAAO,KACb,OAAOI,EAGP,SAASA,EAAMC,EAAM,CACnB,OAAIA,IAAS,KACJP,EAAGO,CAAI,GAEhBR,EAAQ,MAAM,YAAY,EAC1BA,EAAQ,QAAQQ,CAAI,EACpBR,EAAQ,KAAK,YAAY,EAClByB,EACR,CAGD,SAASA,EAAUjB,EAAM,CACvB,OAAOL,EAAK,OAAO,KAAKA,EAAK,IAAG,EAAG,IAAI,EAAID,EAAIM,CAAI,EAAIP,EAAGO,CAAI,CAC/D,CACH,CC3VO,SAASkB,EAASC,EAAS,CAEhC,IAAIC,GADaD,GAAW,CAAE,GACR,qBACtB,OAAIC,GAAW,OACbA,EAAS,IAEJ,CACL,SAAUC,EACV,QAASC,EACT,SAAAC,CACD,EAMD,SAASF,EAAiB7B,EAASC,EAAIC,EAAK,CAE1C,IAAII,EAAW,EAEXe,EAEAW,EACJ,OAAOzB,EAcP,SAASA,EAAMC,EAAM,CACnB,OAAAR,EAAQ,MAAM,UAAU,EACxBA,EAAQ,MAAM,kBAAkB,EACzBS,EAAaD,CAAI,CACzB,CAaD,SAASC,EAAaD,EAAM,CAC1B,OAAIA,IAAS,IACXR,EAAQ,QAAQQ,CAAI,EACpBF,IACOG,GAILH,EAAW,GAAK,CAACsB,EACZ1B,EAAIM,CAAI,GAEjBR,EAAQ,KAAK,kBAAkB,EACxBiC,EAAQzB,CAAI,EACpB,CAYD,SAASyB,EAAQzB,EAAM,CACrB,OAAIA,IAAS,KACJN,EAAIM,CAAI,EAEbA,IAAS,IACXwB,EAAQhC,EAAQ,MAAM,kBAAkB,EACxCqB,EAAO,EACAE,EAAcf,CAAI,GAIvBA,IAAS,IACXR,EAAQ,MAAM,OAAO,EACrBA,EAAQ,QAAQQ,CAAI,EACpBR,EAAQ,KAAK,OAAO,EACbiC,GAELrB,EAAmBJ,CAAI,GACzBR,EAAQ,MAAM,YAAY,EAC1BA,EAAQ,QAAQQ,CAAI,EACpBR,EAAQ,KAAK,YAAY,EAClBiC,IAITjC,EAAQ,MAAM,cAAc,EACrBkC,EAAK1B,CAAI,EACjB,CAYD,SAAS0B,EAAK1B,EAAM,CAClB,OACEA,IAAS,MACTA,IAAS,IACTA,IAAS,IACTI,EAAmBJ,CAAI,GAEvBR,EAAQ,KAAK,cAAc,EACpBiC,EAAQzB,CAAI,IAErBR,EAAQ,QAAQQ,CAAI,EACb0B,EACR,CAaD,SAASX,EAAcf,EAAM,CAE3B,OAAIA,IAAS,IACXR,EAAQ,QAAQQ,CAAI,EACpBa,IACOE,GAILF,IAASf,GACXN,EAAQ,KAAK,kBAAkB,EAC/BA,EAAQ,KAAK,UAAU,EAChBC,EAAGO,CAAI,IAIhBwB,EAAM,KAAO,eACNE,EAAK1B,CAAI,EACjB,CACF,CACH,CAGA,SAASsB,EAAgBK,EAAQ,CAC/B,IAAIC,EAAgBD,EAAO,OAAS,EAChCE,EAAiB,EAEjBC,EAEAC,EAGJ,IACGJ,EAAOE,CAAc,EAAE,CAAC,EAAE,OAAS,cAClCF,EAAOE,CAAc,EAAE,CAAC,EAAE,OAAS,WACpCF,EAAOC,CAAa,EAAE,CAAC,EAAE,OAAS,cACjCD,EAAOC,CAAa,EAAE,CAAC,EAAE,OAAS,UAKpC,IAHAE,EAAQD,EAGD,EAAEC,EAAQF,GACf,GAAID,EAAOG,CAAK,EAAE,CAAC,EAAE,OAAS,eAAgB,CAE5CH,EAAOC,CAAa,EAAE,CAAC,EAAE,KAAO,kBAChCD,EAAOE,CAAc,EAAE,CAAC,EAAE,KAAO,kBACjCA,GAAkB,EAClBD,GAAiB,EACjB,KACD,EAOL,IAFAE,EAAQD,EAAiB,EACzBD,IACO,EAAEE,GAASF,GACZG,IAAU,OACRD,IAAUF,GAAiBD,EAAOG,CAAK,EAAE,CAAC,EAAE,OAAS,eACvDC,EAAQD,IAGVA,IAAUF,GACVD,EAAOG,CAAK,EAAE,CAAC,EAAE,OAAS,gBAE1BH,EAAOI,CAAK,EAAE,CAAC,EAAE,KAAO,eACpBD,IAAUC,EAAQ,IACpBJ,EAAOI,CAAK,EAAE,CAAC,EAAE,IAAMJ,EAAOG,EAAQ,CAAC,EAAE,CAAC,EAAE,IAC5CH,EAAO,OAAOI,EAAQ,EAAGD,EAAQC,EAAQ,CAAC,EAC1CH,GAAiBE,EAAQC,EAAQ,EACjCD,EAAQC,EAAQ,GAElBA,EAAQ,QAGZ,OAAOJ,CACT,CAMA,SAASJ,EAASvB,EAAM,CAEtB,OACEA,IAAS,IACT,KAAK,OAAO,KAAK,OAAO,OAAS,CAAC,EAAE,CAAC,EAAE,OAAS,iBAEpD,CCpPO,SAASgC,EAAKb,EAAS,CAC5B,MAAO,CACL,KAAM,CACH,GAAK/B,CACP,EACD,KAAM,CACH,GAAK8B,EAASC,CAAO,CACvB,CACF,CACH","x_google_ignoreList":[0,1,2]}