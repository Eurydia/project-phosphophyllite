{"version":3,"file":"mdast-util-to-markdown-B2xn9m8u.js","sources":["../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../../node_modules/mdast-util-to-markdown/lib/handle/break.js","../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../../node_modules/mdast-util-to-markdown/lib/handle/code.js","../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../../node_modules/mdast-util-to-markdown/lib/handle/html.js","../../node_modules/mdast-util-to-markdown/lib/handle/image.js","../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../../node_modules/mdast-util-to-markdown/lib/handle/link.js","../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../../node_modules/mdast-util-to-markdown/lib/handle/list.js","../../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../../node_modules/mdast-util-to-markdown/lib/handle/root.js","../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../../node_modules/mdast-util-to-markdown/lib/handle/text.js","../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../../node_modules/mdast-util-to-markdown/lib/handle/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('../types.js').ConstructName} ConstructName\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').State} State\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Exit} Exit\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n"],"names":["blockquote","node","_","state","info","exit","tracker","value","map","line","blank","patternInScope","stack","pattern","listInScope","list","none","index","hardBreak","_1","formatCodeAsIndented","checkFence","marker","code","raw","suffix","sequence","longestStreak","subexit","checkQuote","definition","quote","checkEmphasis","emphasis","emphasisPeek","formatHeadingAsSetext","literalWithBreak","visit","EXIT","toString","heading","rank","html","htmlPeek","image","imagePeek","imageReference","imageReferencePeek","type","alt","reference","inlineCode","inlineCodePeek","expression","match","position","formatLinkAsAutolink","link","linkPeek","linkReference","linkReferencePeek","text","checkBullet","checkBulletOther","bullet","bulletOther","checkBulletOrdered","checkRule","parent","bulletCurrent","useDifferentMarker","firstListItem","item","checkListItemIndent","style","listItem","listItemIndent","size","paragraph","root","d","phrasing","checkStrong","strong","strongPeek","checkRuleRepetition","repetition","thematicBreak","handle"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]}