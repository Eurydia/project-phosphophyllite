{"version":3,"file":"mdast-util-from-markdown-2tgvbwPK.js","sources":["../../node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | null | undefined | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {undefined | void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Fragment | Nodes>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {(this: CompileContext) => undefined} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\n *   Enter a node.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\n *   Exit a node.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n * @property {CompileData} data\n *   Info passed around; key/value store.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\nimport {toString} from 'mdast-util-to-string'\nimport {parse, postprocess, preprocess} from 'micromark'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding\n    encoding = undefined\n  }\n  return compiler(options)(\n    postprocess(\n      parse(options).document().write(preprocess()(value, encoding, true))\n    )\n  )\n}\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index <= length) {\n      const event = events[index]\n      switch (event[1].type) {\n        case 'listUnordered':\n        case 'listOrdered':\n        case 'blockQuote': {\n          if (event[0] === 'enter') {\n            containerBalance++\n          } else {\n            containerBalance--\n          }\n          atMarker = undefined\n          break\n        }\n        case 'lineEndingBlank': {\n          if (event[0] === 'enter') {\n            if (\n              listItem &&\n              !atMarker &&\n              !containerBalance &&\n              !firstBlankLineIndex\n            ) {\n              firstBlankLineIndex = index\n            }\n            atMarker = undefined\n          }\n          break\n        }\n        case 'linePrefix':\n        case 'listItemValue':\n        case 'listItemMarker':\n        case 'listItemPrefix':\n        case 'listItemPrefixWhitespace': {\n          // Empty.\n\n          break\n        }\n        default: {\n          atMarker = undefined\n        }\n      }\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          }\n          listItem = item\n          events.splice(index, 0, ['enter', item, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {undefined}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Nodes} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    siblings.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    }\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): it’s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n    node.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      this.data.expectingFirstListItemValue = undefined\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return\n    this.buffer()\n    this.data.flowCodeInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    this.data.flowCodeInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    /** @type {Array<Nodes>} */\n    const siblings = node.children\n    let tail = siblings[siblings.length - 1]\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: we’ll add `end` later.\n        end: undefined\n      }\n      siblings.push(tail)\n    }\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    // If we’re at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      this.data.atHardBreak = undefined\n      return\n    }\n    if (\n      !this.data.setextHeadingSlurpLineEnding &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    this.data.referenceType = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // Assume a reference.\n    this.data.inReference = true\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    this.data.referenceType = 'full'\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    this.data.characterReferenceType = token.type\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = this.data.characterReferenceType\n    /** @type {string} */\n    let value\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      this.data.characterReferenceType = undefined\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      value = result\n    }\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n  while (++index < extensions.length) {\n    const value = extensions[index]\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n          break\n        }\n        case 'transforms': {\n          const right = extension[key]\n          if (right) {\n            combined[key].push(...right)\n          }\n          break\n        }\n        case 'enter':\n        case 'exit': {\n          const right = extension[key]\n          if (right) {\n            Object.assign(combined[key], right)\n          }\n          break\n        }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n"],"names":["own","fromMarkdown","value","encoding","options","compiler","postprocess","parse","preprocess","config","opener","link","onenterdata","heading","blockQuote","codeFlow","buffer","codeText","definition","emphasis","hardBreak","html","image","listItem","onenterlistitemvalue","list","onenterlistordered","paragraph","onenterreference","strong","thematicBreak","closer","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","onexitdata","onexitcharacterreferencemarker","onexitcharacterreferencevalue","onexitcodefenced","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","onexitlabeltext","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","onexitresource","onexitsetextheading","onexitsetextheadinglinesequence","onexitsetextheadingtext","configure","data","compile","events","tree","context","enter","exit","resume","listStack","index","tail","prepareList","handler","defaultOnError","point","start","length","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","tailIndex","tailEvent","item","create","and","open","token","node","errorHandler","close","onExitError","stringifyPosition","toString","ancestor","label","normalizeIdentifier","depth","siblings","text","referenceType","string","decodeString","fragment","children","type","decodeNumericCharacterReference","decodeNamedCharacterReference","d","combined","extensions","extension","key","right","left"],"mappings":"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","x_google_ignoreList":[0]}