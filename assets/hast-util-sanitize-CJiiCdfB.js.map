{"version":3,"file":"hast-util-sanitize-CJiiCdfB.js","sources":["../../node_modules/hast-util-sanitize/lib/schema.js","../../node_modules/hast-util-sanitize/lib/index.js"],"sourcesContent":["// Couple of ARIA attributes allowed in several, but not all, places.\nconst aria = ['ariaDescribedBy', 'ariaLabel', 'ariaLabelledBy']\n\n/**\n * Default schema.\n *\n * Follows GitHub style sanitation.\n *\n * @type {import('./index.js').Schema}\n */\nexport const defaultSchema = {\n  ancestors: {\n    tbody: ['table'],\n    td: ['table'],\n    th: ['table'],\n    thead: ['table'],\n    tfoot: ['table'],\n    tr: ['table']\n  },\n  attributes: {\n    a: [\n      ...aria,\n      // Note: these 3 are used by GFM footnotes, they do work on all links.\n      'dataFootnoteBackref',\n      'dataFootnoteRef',\n      ['className', 'data-footnote-backref'],\n      'href'\n    ],\n    blockquote: ['cite'],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `code` as HTML in markdown, they adds it some other way.\n    // We canâ€™t do that, so we have to allow it.\n    code: [['className', /^language-./]],\n    del: ['cite'],\n    div: ['itemScope', 'itemType'],\n    dl: [...aria],\n    // Note: this is used by GFM footnotes.\n    h2: [['className', 'sr-only']],\n    img: [...aria, 'longDesc', 'src'],\n    // Note: `input` is not normally allowed by GH, when manually writing\n    // it in markdown, they add it from tasklists some other way.\n    // We canâ€™t do that, so we have to allow it.\n    input: [\n      ['disabled', true],\n      ['type', 'checkbox']\n    ],\n    ins: ['cite'],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `li` as HTML in markdown, they adds it some other way.\n    // We canâ€™t do that, so we have to allow it.\n    li: [['className', 'task-list-item']],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `ol` as HTML in markdown, they adds it some other way.\n    // We canâ€™t do that, so we have to allow it.\n    ol: [...aria, ['className', 'contains-task-list']],\n    q: ['cite'],\n    section: ['dataFootnotes', ['className', 'footnotes']],\n    source: ['srcSet'],\n    summary: [...aria],\n    table: [...aria],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `ol` as HTML in markdown, they adds it some other way.\n    // We canâ€™t do that, so we have to allow it.\n    ul: [...aria, ['className', 'contains-task-list']],\n    '*': [\n      'abbr',\n      'accept',\n      'acceptCharset',\n      'accessKey',\n      'action',\n      'align',\n      'alt',\n      'axis',\n      'border',\n      'cellPadding',\n      'cellSpacing',\n      'char',\n      'charOff',\n      'charSet',\n      'checked',\n      'clear',\n      'colSpan',\n      'color',\n      'cols',\n      'compact',\n      'coords',\n      'dateTime',\n      'dir',\n      // Note: `disabled` is technically allowed on all elements by GH.\n      // But it is useless on everything except `input`.\n      // Because `input`s are normally not allowed, but we allow them for\n      // checkboxes due to tasklists, we allow `disabled` only there.\n      'encType',\n      'frame',\n      'hSpace',\n      'headers',\n      'height',\n      'hrefLang',\n      'htmlFor',\n      'id',\n      'isMap',\n      'itemProp',\n      'label',\n      'lang',\n      'maxLength',\n      'media',\n      'method',\n      'multiple',\n      'name',\n      'noHref',\n      'noShade',\n      'noWrap',\n      'open',\n      'prompt',\n      'readOnly',\n      'rev',\n      'rowSpan',\n      'rows',\n      'rules',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'span',\n      'start',\n      'summary',\n      'tabIndex',\n      'title',\n      'useMap',\n      'vAlign',\n      'value',\n      'width'\n    ]\n  },\n  clobber: ['ariaDescribedBy', 'ariaLabelledBy', 'id', 'name'],\n  clobberPrefix: 'user-content-',\n  protocols: {\n    cite: ['http', 'https'],\n    href: ['http', 'https', 'irc', 'ircs', 'mailto', 'xmpp'],\n    longDesc: ['http', 'https'],\n    src: ['http', 'https']\n  },\n  required: {\n    input: {disabled: true, type: 'checkbox'}\n  },\n  strip: ['script'],\n  tagNames: [\n    'a',\n    'b',\n    'blockquote',\n    'br',\n    'code',\n    'dd',\n    'del',\n    'details',\n    'div',\n    'dl',\n    'dt',\n    'em',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'hr',\n    'i',\n    'img',\n    // Note: `input` is not normally allowed by GH, when manually writing\n    // it in markdown, they add it from tasklists some other way.\n    // We canâ€™t do that, so we have to allow it.\n    'input',\n    'ins',\n    'kbd',\n    'li',\n    'ol',\n    'p',\n    'picture',\n    'pre',\n    'q',\n    'rp',\n    'rt',\n    'ruby',\n    's',\n    'samp',\n    'section',\n    'source',\n    'span',\n    'strike',\n    'strong',\n    'sub',\n    'summary',\n    'sup',\n    'table',\n    'tbody',\n    'td',\n    'tfoot',\n    'th',\n    'thead',\n    'tr',\n    'tt',\n    'ul',\n    'var'\n  ]\n}\n","/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @typedef {[string, ...Array<Exclude<Properties[keyof Properties], Array<any>> | RegExp>] | string} PropertyDefinition\n *   Definition for a property.\n *\n * @typedef Schema\n *   Schema that defines what nodes and properties are allowed.\n *\n *   The default schema is `defaultSchema`, which follows how GitHub cleans.\n *   If any top-level key is missing in the given schema, the corresponding\n *   value of the default schema is used.\n *\n *   To extend the standard schema with a few changes, clone `defaultSchema`\n *   like so:\n *\n *   ```js\n *   import deepmerge from 'deepmerge'\n *   import {h} from 'hastscript'\n *   import {defaultSchema, sanitize} from 'hast-util-sanitize'\n *\n *   // This allows `className` on all elements.\n *   const schema = deepmerge(defaultSchema, {attributes: {'*': ['className']}})\n *\n *   const tree = sanitize(h('div', {className: ['foo']}), schema)\n *\n *   // `tree` still has `className`.\n *   console.log(tree)\n *   // {\n *   //   type: 'element',\n *   //   tagName: 'div',\n *   //   properties: {className: ['foo']},\n *   //   children: []\n *   // }\n *   ```\n * @property {boolean | null | undefined} [allowComments=false]\n *   Whether to allow comment nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowComments: true\n *   ```\n * @property {boolean | null | undefined} [allowDoctypes=false]\n *   Whether to allow doctype nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowDoctypes: true\n *   ```\n * @property {Record<string, Array<string>> | null | undefined} [ancestors]\n *   Map of tag names to a list of tag names which are required ancestors\n *   (default: `defaultSchema.ancestors`).\n *\n *   Elements with these tag names will be ignored if they occur outside of one\n *   of their allowed parents.\n *\n *   For example:\n *\n *   ```js\n *   ancestors: {\n *     tbody: ['table'],\n *     // â€¦\n *     tr: ['table']\n *   }\n *   ```\n * @property {Record<string, Array<PropertyDefinition>> | null | undefined} [attributes]\n *   Map of tag names to allowed property names (default:\n *   `defaultSchema.attributes`).\n *\n *   The special key `'*'` as a tag name defines property names allowed on all\n *   elements.\n *\n *   The special value `'data*'` as a property name can be used to allow all\n *   `data` properties.\n *\n *   For example:\n *\n *   ```js\n *   attributes: {\n *     'ariaDescribedBy', 'ariaLabel', 'ariaLabelledBy', â€¦, 'href'\n *     // â€¦\n *     '*': [\n *       'abbr',\n *       'accept',\n *       'acceptCharset',\n *       // â€¦\n *       'vAlign',\n *       'value',\n *       'width'\n *     ]\n *   }\n *   ```\n *\n *   Instead of a single string in the array, which allows any property value\n *   for the field, you can use an array to allow several values.\n *   For example, `input: ['type']` allows `type` set to any value on `input`s.\n *   But `input: [['type', 'checkbox', 'radio']]` allows `type` when set to\n *   `'checkbox'` or `'radio'`.\n *\n *   You can use regexes, so for example `span: [['className', /^hljs-/]]`\n *   allows any class that starts with `hljs-` on `span`s.\n *\n *   When comma- or space-separated values are used (such as `className`), each\n *   value in is checked individually.\n *   For example, to allow certain classes on `span`s for syntax highlighting,\n *   use `span: [['className', 'number', 'operator', 'token']]`.\n *   This will allow `'number'`, `'operator'`, and `'token'` classes, but drop\n *   others.\n * @property {Array<string> | null | undefined} [clobber]\n *   List of property names that clobber (default: `defaultSchema.clobber`).\n *\n *   For example:\n *\n *   ```js\n *   clobber: ['ariaDescribedBy', 'ariaLabelledBy', 'id', 'name']\n *   ```\n * @property {string | null | undefined} [clobberPrefix]\n *   Prefix to use before clobbering properties (default:\n *   `defaultSchema.clobberPrefix`).\n *\n *   For example:\n *\n *   ```js\n *   clobberPrefix: 'user-content-'\n *   ```\n * @property {Record<string, Array<string> | null | undefined> | null | undefined} [protocols]\n *   Map of *property names* to allowed protocols (default:\n *   `defaultSchema.protocols`).\n *\n *   This defines URLs that are always allowed to have local URLs (relative to\n *   the current website, such as `this`, `#this`, `/this`, or `?this`), and\n *   only allowed to have remote URLs (such as `https://example.com`) if they\n *   use a known protocol.\n *\n *   For example:\n *\n *   ```js\n *   protocols: {\n *     cite: ['http', 'https'],\n *     // â€¦\n *     src: ['http', 'https']\n *   }\n *   ```\n * @property {Record<string, Record<string, Properties[keyof Properties]>> | null | undefined} [required]\n *   Map of tag names to required property names with a default value\n *   (default: `defaultSchema.required`).\n *\n *   This defines properties that must be set.\n *   If a field does not exist (after the element was made safe), these will be\n *   added with the given value.\n *\n *   For example:\n *\n *   ```js\n *   required: {\n *     input: {disabled: true, type: 'checkbox'}\n *   }\n *   ```\n *\n *   > ðŸ‘‰ **Note**: properties are first checked based on `schema.attributes`,\n *   > then on `schema.required`.\n *   > That means properties could be removed by `attributes` and then added\n *   > again with `required`.\n * @property {Array<string> | null | undefined} [strip]\n *   List of tag names to strip from the tree (default: `defaultSchema.strip`).\n *\n *   By default, unsafe elements (those not in `schema.tagNames`) are replaced\n *   by what they contain.\n *   This option can drop their contents.\n *\n *   For example:\n *\n *   ```js\n *   strip: ['script']\n *   ```\n * @property {Array<string> | null | undefined} [tagNames]\n *   List of allowed tag names (default: `defaultSchema.tagNames`).\n *\n *   For example:\n *\n *   ```js\n *   tagNames: [\n *     'a',\n *     'b',\n *     // â€¦\n *     'ul',\n *     'var'\n *   ]\n *   ```\n *\n * @typedef State\n *   Info passed around.\n * @property {Readonly<Schema>} schema\n *   Schema.\n * @property {Array<string>} stack\n *   Tag names of ancestors.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {position} from 'unist-util-position'\nimport {defaultSchema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Sanitize a tree.\n *\n * @param {Readonly<Nodes>} node\n *   Unsafe tree.\n * @param {Readonly<Schema> | null | undefined} [options]\n *   Configuration (default: `defaultSchema`).\n * @returns {Nodes}\n *   New, safe tree.\n */\nexport function sanitize(node, options) {\n  /** @type {Nodes} */\n  let ctx = {type: 'root', children: []}\n\n  /** @type {State} */\n  const state = {\n    schema: options ? {...defaultSchema, ...options} : defaultSchema,\n    stack: []\n  }\n  const replace = transform(state, node)\n\n  if (replace) {\n    if (Array.isArray(replace)) {\n      if (replace.length === 1) {\n        ctx = replace[0]\n      } else {\n        ctx.children = replace\n      }\n    } else {\n      ctx = replace\n    }\n  }\n\n  return ctx\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} node\n *   Unsafe node.\n * @returns {Array<ElementContent> | Nodes | undefined}\n *   Safe result.\n */\nfunction transform(state, node) {\n  if (node && typeof node === 'object') {\n    const unsafe = /** @type {Record<string, Readonly<unknown>>} */ (node)\n    const type = typeof unsafe.type === 'string' ? unsafe.type : ''\n\n    switch (type) {\n      case 'comment': {\n        return comment(state, unsafe)\n      }\n\n      case 'doctype': {\n        return doctype(state, unsafe)\n      }\n\n      case 'element': {\n        return element(state, unsafe)\n      }\n\n      case 'root': {\n        return root(state, unsafe)\n      }\n\n      case 'text': {\n        return text(state, unsafe)\n      }\n\n      default:\n    }\n  }\n}\n\n/**\n * Make a safe comment.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe comment-like value.\n * @returns {Comment | undefined}\n *   Safe comment (if with `allowComments`).\n */\nfunction comment(state, unsafe) {\n  if (state.schema.allowComments) {\n    // See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n    const result = typeof unsafe.value === 'string' ? unsafe.value : ''\n    const index = result.indexOf('-->')\n    const value = index < 0 ? result : result.slice(0, index)\n\n    /** @type {Comment} */\n    const node = {type: 'comment', value}\n\n    patch(node, unsafe)\n\n    return node\n  }\n}\n\n/**\n * Make a safe doctype.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe doctype-like value.\n * @returns {Doctype | undefined}\n *   Safe doctype (if with `allowDoctypes`).\n */\nfunction doctype(state, unsafe) {\n  if (state.schema.allowDoctypes) {\n    /** @type {Doctype} */\n    const node = {type: 'doctype'}\n\n    patch(node, unsafe)\n\n    return node\n  }\n}\n\n/**\n * Make a safe element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe element-like value.\n * @returns {Array<ElementContent> | Element | undefined}\n *   Safe element.\n */\nfunction element(state, unsafe) {\n  const name = typeof unsafe.tagName === 'string' ? unsafe.tagName : ''\n\n  state.stack.push(name)\n\n  const content = /** @type {Array<ElementContent>} */ (\n    children(state, unsafe.children)\n  )\n  const props = properties(state, unsafe.properties)\n\n  state.stack.pop()\n\n  let safeElement = false\n\n  if (\n    name &&\n    name !== '*' &&\n    (!state.schema.tagNames || state.schema.tagNames.includes(name))\n  ) {\n    safeElement = true\n\n    // Some nodes can break out of their context if they donâ€™t have a certain\n    // ancestor.\n    if (state.schema.ancestors && own.call(state.schema.ancestors, name)) {\n      const ancestors = state.schema.ancestors[name]\n      let index = -1\n\n      safeElement = false\n\n      while (++index < ancestors.length) {\n        if (state.stack.includes(ancestors[index])) {\n          safeElement = true\n        }\n      }\n    }\n  }\n\n  if (!safeElement) {\n    return state.schema.strip && !state.schema.strip.includes(name)\n      ? content\n      : undefined\n  }\n\n  /** @type {Element} */\n  const node = {\n    type: 'element',\n    tagName: name,\n    properties: props,\n    children: content\n  }\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make a safe root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe root-like value.\n * @returns {Root}\n *   Safe root.\n */\nfunction root(state, unsafe) {\n  const content = /** @type {Array<RootContent>} */ (\n    children(state, unsafe.children)\n  )\n\n  /** @type {Root} */\n  const node = {type: 'root', children: content}\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make a safe text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe text-like value.\n * @returns {Text}\n *   Safe text.\n */\nfunction text(_, unsafe) {\n  const value = typeof unsafe.value === 'string' ? unsafe.value : ''\n  /** @type {Text} */\n  const node = {type: 'text', value}\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make children safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} children\n *   Unsafe value.\n * @returns {Array<Nodes>}\n *   Safe children.\n */\nfunction children(state, children) {\n  /** @type {Array<Nodes>} */\n  const results = []\n\n  if (Array.isArray(children)) {\n    const childrenUnknown = /** @type {Array<Readonly<unknown>>} */ (children)\n    let index = -1\n\n    while (++index < childrenUnknown.length) {\n      const value = transform(state, childrenUnknown[index])\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value)\n        } else {\n          results.push(value)\n        }\n      }\n    }\n  }\n\n  return results\n}\n\n/**\n * Make element properties safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} properties\n *   Unsafe value.\n * @returns {Properties}\n *   Safe value.\n */\nfunction properties(state, properties) {\n  const tagName = state.stack[state.stack.length - 1]\n  const attributes = state.schema.attributes\n  const required = state.schema.required\n  const specific =\n    attributes && own.call(attributes, tagName)\n      ? attributes[tagName]\n      : undefined\n  const defaults =\n    attributes && own.call(attributes, '*') ? attributes['*'] : undefined\n  const props = /** @type {Readonly<Record<string, Readonly<unknown>>>} */ (\n    properties && typeof properties === 'object' ? properties : {}\n  )\n  /** @type {Properties} */\n  const result = {}\n  /** @type {string} */\n  let key\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      const unsafe = props[key]\n      let safe = propertyValue(\n        state,\n        findDefinition(specific, key),\n        key,\n        unsafe\n      )\n\n      if (safe === null || safe === undefined) {\n        safe = propertyValue(state, findDefinition(defaults, key), key, unsafe)\n      }\n\n      if (safe !== null && safe !== undefined) {\n        result[key] = safe\n      }\n    }\n  }\n\n  if (required && own.call(required, tagName)) {\n    const properties = required[tagName]\n\n    for (key in properties) {\n      if (own.call(properties, key) && !own.call(result, key)) {\n        result[key] = properties[key]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition> | undefined} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but an array).\n * @returns {Array<number | string> | boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValue(state, definition, key, value) {\n  return definition\n    ? Array.isArray(value)\n      ? propertyValueMany(state, definition, key, value)\n      : propertyValuePrimitive(state, definition, key, value)\n    : undefined\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<Array<Readonly<unknown>>>} values\n *   Unsafe value (but an array).\n * @returns {Array<number | string>}\n *   Safe value.\n */\nfunction propertyValueMany(state, definition, key, values) {\n  let index = -1\n  /** @type {Array<number | string>} */\n  const result = []\n\n  while (++index < values.length) {\n    const value = propertyValuePrimitive(state, definition, key, values[index])\n\n    if (typeof value === 'number' || typeof value === 'string') {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value which is a primitive.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but not an array).\n * @returns {boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValuePrimitive(state, definition, key, value) {\n  if (\n    typeof value !== 'boolean' &&\n    typeof value !== 'number' &&\n    typeof value !== 'string'\n  ) {\n    return\n  }\n\n  if (!safeProtocol(state, key, value)) {\n    return\n  }\n\n  // Just a string, or only one item in an array, means all values are OK.\n  // More than one item means an allow list.\n  if (typeof definition === 'object' && definition.length > 1) {\n    let ok = false\n    let index = 0 // Ignore `key`, which is the first item.\n\n    while (++index < definition.length) {\n      const allowed = definition[index]\n\n      // Expression.\n      if (allowed && typeof allowed === 'object' && 'flags' in allowed) {\n        if (allowed.test(String(value))) {\n          ok = true\n          break\n        }\n      }\n      // Primitive.\n      else if (allowed === value) {\n        ok = true\n        break\n      }\n    }\n\n    if (!ok) return\n  }\n\n  return state.schema.clobber &&\n    state.schema.clobberPrefix &&\n    state.schema.clobber.includes(key)\n    ? state.schema.clobberPrefix + value\n    : value\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value.\n * @returns {boolean}\n *   Whether itâ€™s a safe value.\n */\nfunction safeProtocol(state, key, value) {\n  const protocols =\n    state.schema.protocols && own.call(state.schema.protocols, key)\n      ? state.schema.protocols[key]\n      : undefined\n\n  // No protocols defined? Then everything is fine.\n  if (!protocols || protocols.length === 0) {\n    return true\n  }\n\n  const url = String(value)\n  const colon = url.indexOf(':')\n  const questionMark = url.indexOf('?')\n  const numberSign = url.indexOf('#')\n  const slash = url.indexOf('/')\n\n  if (\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign)\n  ) {\n    return true\n  }\n\n  let index = -1\n\n  while (++index < protocols.length) {\n    const protocol = protocols[index]\n\n    if (\n      colon === protocol.length &&\n      url.slice(0, protocol.length) === protocol\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Add data and position.\n *\n * @param {Nodes} node\n *   Node to patch safe data and position on.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe node-like value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(node, unsafe) {\n  const cleanPosition = position(\n    // @ts-expect-error: looks like a node.\n    unsafe\n  )\n\n  if (unsafe.data) {\n    node.data = structuredClone(unsafe.data)\n  }\n\n  if (cleanPosition) node.position = cleanPosition\n}\n\n/**\n *\n * @param {Readonly<Array<PropertyDefinition>> | undefined} definitions\n * @param {string} key\n * @returns {Readonly<PropertyDefinition> | undefined}\n */\nfunction findDefinition(definitions, key) {\n  /** @type {PropertyDefinition | undefined} */\n  let dataDefault\n  let index = -1\n\n  if (definitions) {\n    while (++index < definitions.length) {\n      const entry = definitions[index]\n      const name = typeof entry === 'string' ? entry : entry[0]\n\n      if (name === key) {\n        return entry\n      }\n\n      if (name === 'data*') dataDefault = entry\n    }\n  }\n\n  if (key.length > 4 && key.slice(0, 4).toLowerCase() === 'data') {\n    return dataDefault\n  }\n}\n"],"names":["aria","defaultSchema","own","sanitize","node","options","ctx","state","replace","transform","unsafe","comment","doctype","element","root","text","result","index","patch","name","content","children","props","properties","safeElement","ancestors","_","results","childrenUnknown","value","tagName","attributes","required","specific","defaults","key","safe","propertyValue","findDefinition","definition","propertyValueMany","propertyValuePrimitive","values","safeProtocol","ok","allowed","protocols","url","colon","questionMark","numberSign","slash","protocol","cleanPosition","position","structuredClone","definitions","dataDefault","entry"],"mappings":"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","x_google_ignoreList":[0,1]}