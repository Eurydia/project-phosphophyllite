{"version":3,"file":"micromark-extension-gfm-strikethrough-DLG0h2kg.js","sources":["../../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (default: `true`).\n *\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n            const insideSpan = context.parser.constructs.insideSpan.null\n            if (insideSpan) {\n              // Between.\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n"],"names":["gfmStrikethrough","options","single","tokenizer","tokenizeStrikethrough","resolveAllStrikethrough","events","context","index","open","strikethrough","text","nextEvents","insideSpan","splice","resolveAll","effects","ok","nok","previous","size","start","code","more","before","classifyCharacter","token","after"],"mappings":"0LA8BO,SAASA,EAAiBC,EAAS,CAExC,IAAIC,GADaD,GAAW,CAAE,GACR,YACtB,MAAME,EAAY,CAChB,SAAUC,EACV,WAAYC,CACb,EACD,OAAIH,GAAW,OACbA,EAAS,IAEJ,CACL,KAAM,CACH,IAAMC,CACR,EACD,WAAY,CACV,KAAM,CAACA,CAAS,CACjB,EACD,iBAAkB,CAChB,KAAM,CAAC,GAAG,CACX,CACF,EAOD,SAASE,EAAwBC,EAAQC,EAAS,CAChD,IAAIC,EAAQ,GAGZ,KAAO,EAAEA,EAAQF,EAAO,QAEtB,GACEA,EAAOE,CAAK,EAAE,CAAC,IAAM,SACrBF,EAAOE,CAAK,EAAE,CAAC,EAAE,OAAS,kCAC1BF,EAAOE,CAAK,EAAE,CAAC,EAAE,OACjB,CACA,IAAIC,EAAOD,EAGX,KAAOC,KAEL,GACEH,EAAOG,CAAI,EAAE,CAAC,IAAM,QACpBH,EAAOG,CAAI,EAAE,CAAC,EAAE,OAAS,kCACzBH,EAAOG,CAAI,EAAE,CAAC,EAAE,OAEhBH,EAAOE,CAAK,EAAE,CAAC,EAAE,IAAI,OAASF,EAAOE,CAAK,EAAE,CAAC,EAAE,MAAM,SACnDF,EAAOG,CAAI,EAAE,CAAC,EAAE,IAAI,OAASH,EAAOG,CAAI,EAAE,CAAC,EAAE,MAAM,OACrD,CACAH,EAAOE,CAAK,EAAE,CAAC,EAAE,KAAO,wBACxBF,EAAOG,CAAI,EAAE,CAAC,EAAE,KAAO,wBAGvB,MAAMC,EAAgB,CACpB,KAAM,gBACN,MAAO,OAAO,OAAO,CAAE,EAAEJ,EAAOG,CAAI,EAAE,CAAC,EAAE,KAAK,EAC9C,IAAK,OAAO,OAAO,CAAE,EAAEH,EAAOE,CAAK,EAAE,CAAC,EAAE,GAAG,CAC5C,EAGKG,EAAO,CACX,KAAM,oBACN,MAAO,OAAO,OAAO,CAAE,EAAEL,EAAOG,CAAI,EAAE,CAAC,EAAE,GAAG,EAC5C,IAAK,OAAO,OAAO,CAAE,EAAEH,EAAOE,CAAK,EAAE,CAAC,EAAE,KAAK,CAC9C,EAIKI,EAAa,CACjB,CAAC,QAASF,EAAeH,CAAO,EAChC,CAAC,QAASD,EAAOG,CAAI,EAAE,CAAC,EAAGF,CAAO,EAClC,CAAC,OAAQD,EAAOG,CAAI,EAAE,CAAC,EAAGF,CAAO,EACjC,CAAC,QAASI,EAAMJ,CAAO,CACxB,EACKM,EAAaN,EAAQ,OAAO,WAAW,WAAW,KACpDM,GAEFC,EACEF,EACAA,EAAW,OACX,EACAG,EAAWF,EAAYP,EAAO,MAAMG,EAAO,EAAGD,CAAK,EAAGD,CAAO,CAC9D,EAIHO,EAAOF,EAAYA,EAAW,OAAQ,EAAG,CACvC,CAAC,OAAQD,EAAMJ,CAAO,EACtB,CAAC,QAASD,EAAOE,CAAK,EAAE,CAAC,EAAGD,CAAO,EACnC,CAAC,OAAQD,EAAOE,CAAK,EAAE,CAAC,EAAGD,CAAO,EAClC,CAAC,OAAQG,EAAeH,CAAO,CAC7C,CAAa,EACDO,EAAOR,EAAQG,EAAO,EAAGD,EAAQC,EAAO,EAAGG,CAAU,EACrDJ,EAAQC,EAAOG,EAAW,OAAS,EACnC,KACD,CAEJ,CAGH,IADAJ,EAAQ,GACD,EAAEA,EAAQF,EAAO,QAClBA,EAAOE,CAAK,EAAE,CAAC,EAAE,OAAS,mCAC5BF,EAAOE,CAAK,EAAE,CAAC,EAAE,KAAO,QAG5B,OAAOF,CACR,CAMD,SAASF,EAAsBY,EAASC,EAAIC,EAAK,CAC/C,MAAMC,EAAW,KAAK,SAChBb,EAAS,KAAK,OACpB,IAAIc,EAAO,EACX,OAAOC,EAGP,SAASA,EAAMC,EAAM,CACnB,OACEH,IAAa,KACbb,EAAOA,EAAO,OAAS,CAAC,EAAE,CAAC,EAAE,OAAS,kBAE/BY,EAAII,CAAI,GAEjBN,EAAQ,MAAM,gCAAgC,EACvCO,EAAKD,CAAI,EACjB,CAGD,SAASC,EAAKD,EAAM,CAClB,MAAME,EAASC,EAAkBN,CAAQ,EACzC,GAAIG,IAAS,IAEX,OAAIF,EAAO,EAAUF,EAAII,CAAI,GAC7BN,EAAQ,QAAQM,CAAI,EACpBF,IACOG,GAET,GAAIH,EAAO,GAAK,CAAClB,EAAQ,OAAOgB,EAAII,CAAI,EACxC,MAAMI,EAAQV,EAAQ,KAAK,gCAAgC,EACrDW,EAAQF,EAAkBH,CAAI,EACpC,OAAAI,EAAM,MAAQ,CAACC,GAAUA,IAAU,GAAK,EAAQH,EAChDE,EAAM,OAAS,CAACF,GAAWA,IAAW,GAAK,EAAQG,EAC5CV,EAAGK,CAAI,CACf,CACF,CACH","x_google_ignoreList":[0]}