{"version":3,"file":"stringify-entities-DX2AxK7f.js","sources":["../../node_modules/stringify-entities/lib/core.js","../../node_modules/stringify-entities/lib/util/to-hexadecimal.js","../../node_modules/stringify-entities/lib/util/to-decimal.js","../../node_modules/stringify-entities/lib/constant/dangerous.js","../../node_modules/stringify-entities/lib/util/to-named.js","../../node_modules/stringify-entities/lib/util/format-smart.js","../../node_modules/stringify-entities/lib/index.js"],"sourcesContent":["/**\n * @typedef CoreOptions\n * @property {Array<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset ? charactersToExpression(options.subset) : /[\"&'<>`]/g,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(\n        // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n        /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g,\n        basic\n      )\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * @param {Array<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n","/**\n * Configurable ways to encode characters as hexadecimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nexport function toHexadecimal(code, next, omit) {\n  const value = '&#x' + code.toString(16).toUpperCase()\n  return omit && next && !/[\\dA-Fa-f]/.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n","/**\n * Configurable ways to encode characters as decimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nexport function toDecimal(code, next, omit) {\n  const value = '&#' + String(code)\n  return omit && next && !/\\d/.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n","/**\n * List of legacy (that don’t need a trailing `;`) named references which could,\n * depending on what follows them, turn into a different meaning\n *\n * @type {Array<string>}\n */\nexport const dangerous = [\n  'cent',\n  'copy',\n  'divide',\n  'gt',\n  'lt',\n  'not',\n  'para',\n  'times'\n]\n","import {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterEntitiesHtml4} from 'character-entities-html4'\nimport {dangerous} from '../constant/dangerous.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * `characterEntitiesHtml4` but inverted.\n *\n * @type {Record<string, string>}\n */\nconst characters = {}\n\n/** @type {string} */\nlet key\n\nfor (key in characterEntitiesHtml4) {\n  if (own.call(characterEntitiesHtml4, key)) {\n    characters[characterEntitiesHtml4[key]] = key\n  }\n}\n\n/**\n * Configurable ways to encode characters as named references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @param {boolean|undefined} attribute\n * @returns {string}\n */\nexport function toNamed(code, next, omit, attribute) {\n  const character = String.fromCharCode(code)\n\n  if (own.call(characters, character)) {\n    const name = characters[character]\n    const value = '&' + name\n\n    if (\n      omit &&\n      characterEntitiesLegacy.includes(name) &&\n      !dangerous.includes(name) &&\n      (!attribute ||\n        (next &&\n          next !== 61 /* `=` */ &&\n          /[^\\da-z]/i.test(String.fromCharCode(next))))\n    ) {\n      return value\n    }\n\n    return value + ';'\n  }\n\n  return ''\n}\n","/**\n * @typedef FormatSmartOptions\n * @property {boolean} [useNamedReferences=false]\n *   Prefer named character references (`&amp;`) where possible.\n * @property {boolean} [useShortestReferences=false]\n *   Prefer the shortest possible reference, if that results in less bytes.\n *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.\n * @property {boolean} [omitOptionalSemicolons=false]\n *   Whether to omit semicolons when possible.\n *   **Note**: This creates what HTML calls “parse errors” but is otherwise still valid HTML — don’t use this except when building a minifier.\n *   Omitting semicolons is possible for certain named and numeric references in some cases.\n * @property {boolean} [attribute=false]\n *   Create character references which don’t fail in attributes.\n *   **Note**: `attribute` only applies when operating dangerously with\n *   `omitOptionalSemicolons: true`.\n */\n\nimport {toHexadecimal} from './to-hexadecimal.js'\nimport {toDecimal} from './to-decimal.js'\nimport {toNamed} from './to-named.js'\n\n/**\n * Configurable ways to encode a character yielding pretty or small results.\n *\n * @param {number} code\n * @param {number} next\n * @param {FormatSmartOptions} options\n * @returns {string}\n */\nexport function formatSmart(code, next, options) {\n  let numeric = toHexadecimal(code, next, options.omitOptionalSemicolons)\n  /** @type {string|undefined} */\n  let named\n\n  if (options.useNamedReferences || options.useShortestReferences) {\n    named = toNamed(\n      code,\n      next,\n      options.omitOptionalSemicolons,\n      options.attribute\n    )\n  }\n\n  // Use the shortest numeric reference when requested.\n  // A simple algorithm would use decimal for all code points under 100, as\n  // those are shorter than hexadecimal:\n  //\n  // * `&#99;` vs `&#x63;` (decimal shorter)\n  // * `&#100;` vs `&#x64;` (equal)\n  //\n  // However, because we take `next` into consideration when `omit` is used,\n  // And it would be possible that decimals are shorter on bigger values as\n  // well if `next` is hexadecimal but not decimal, we instead compare both.\n  if (\n    (options.useShortestReferences || !named) &&\n    options.useShortestReferences\n  ) {\n    const decimal = toDecimal(code, next, options.omitOptionalSemicolons)\n\n    if (decimal.length < numeric.length) {\n      numeric = decimal\n    }\n  }\n\n  return named &&\n    (!options.useShortestReferences || named.length < numeric.length)\n    ? named\n    : numeric\n}\n","/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n"],"names":["core","value","options","charactersToExpression","basic","surrogate","pair","index","all","character","subset","groups","toHexadecimal","code","next","omit","toDecimal","dangerous","own","characters","key","characterEntitiesHtml4","toNamed","attribute","name","characterEntitiesLegacy","formatSmart","numeric","named","decimal","stringifyEntities"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}